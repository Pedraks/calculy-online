<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE VOID - Single File Horror</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #a0a0a0;
            --alert-color: #8a0000;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            cursor: none; /* Hide default cursor */
            user-select: none;
        }

        /* CANVAS CONTAINER */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            image-rendering: pixelated; /* Retro look */
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
        }

        /* UI OVERLAYS */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* MENU SCREEN */
        #menu-screen {
            background: rgba(0,0,0,0.8);
            pointer-events: auto;
            z-index: 20;
            text-align: center;
        }

        h1 {
            color: #fff;
            font-size: 4rem;
            text-shadow: 2px 0 var(--alert-color), -2px 0 blue;
            animation: glitch 2s infinite linear alternate-reverse;
            margin-bottom: 0.5rem;
        }

        p { color: var(--text-color); margin: 5px; }
        
        button {
            background: transparent;
            border: 2px solid var(--text-color);
            color: var(--text-color);
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: inherit;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--text-color);
            color: #000;
            border-color: #fff;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--alert-color);
            font-weight: bold;
            display: none;
            text-shadow: 0 0 5px red;
        }

        /* VHS / GLITCH EFFECTS */
        .vhs-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 5;
            animation: scanline 10s linear infinite;
        }

        .noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.05;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48ZmlsdGVyIGlkPSJnoiPjxmZVR1cmJ1bGVuY2UgdHlwZT0iZnJhY3RhbE5vaXNlIiBiYXNlRnJlcXVlbmN5PSIwLjY1IiBudW1PY3RhdmVzPSIzIiBzdGl0Y2hUaWxlcz0ic3RpdGNoIi8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsdGVyPSJ1cmwoI2cpIiBvcGFjaXR5PSIxIi8+PC9zdmc+');
            z-index: 6;
        }

        .vignette {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, black 100%);
            z-index: 4;
            pointer-events: none;
        }

        /* ANIMATIONS */
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        @keyframes scanline {
            0% { background-position: 0% 0%; }
            100% { background-position: 0% 100%; }
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        
        #jumpscare-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: black;
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="vhs-overlay"></div>
        <div class="noise"></div>
        <div class="vignette"></div>

        <canvas id="gameCanvas"></canvas>

        <div id="hud">SANITY: <span id="sanity-val">100</span>% <br> ORBS: <span id="orb-val">0</span>/3</div>

        <div id="menu-screen" class="ui-layer">
            <h1>THE VOID</h1>
            <p>Collect 3 Orbs to unlock the Exit.</p>
            <p>Avoid the Shadows. Stay in the light.</p>
            <p>Controls: WASD to Move | Mouse to Aim</p>
            <button id="start-btn">ENTER DARKNESS</button>
        </div>

        <div id="death-screen" class="ui-layer" style="display:none; background:black;">
            <h1 style="color:red; font-family:serif;">YOU DIED</h1>
            <p>The darkness consumed you.</p>
            <button onclick="location.reload()">TRY AGAIN</button>
        </div>
        
        <div id="win-screen" class="ui-layer" style="display:none; background:#111;">
            <h1 style="color:white;">ESCAPED</h1>
            <p>You survived... for now.</p>
            <button onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>
    
    <div id="jumpscare-overlay"><canvas id="scareCanvas"></canvas></div>

<script>
/**
 * THE VOID - SINGLE FILE HORROR ENGINE
 * * 1. Audio Engine (Web Audio API) - Procedural sounds
 * 2. Input Handling
 * 3. Map Generation (Cellular-like rooms)
 * 4. Rendering (Canvas API with 'destination-out' lighting)
 * 5. Entity AI & State Management
 */

// --- CONFIGURATION ---
const TILE_SIZE = 40;
const MAP_WIDTH = 40;
const MAP_HEIGHT = 30;
const PLAYER_SPEED = 3;
const ENEMY_SPEED = 1.8;
const FLASHLIGHT_RADIUS = 150;
const FLASHLIGHT_ANGLE = 0.6; // Radians

// --- STATE ---
let canvas, ctx, scareCanvas, scareCtx;
let lastTime = 0;
let gameState = 'MENU'; // MENU, PLAYING, DEAD, WIN
let width, height;

// --- AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    masterGain: null,
    
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.5;
            this.masterGain.connect(this.ctx.destination);
        }
        if(this.ctx.state === 'suspended') this.ctx.resume();
    },

    playTone: function(freq, type, duration, vol = 0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    playStep: function() {
        // Filtered noise for footsteps
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.1;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 150;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.2;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        noise.start();
    },

    playAmbient: function() {
        // Deep drone
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = 50;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.05;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        
        // LFO for throbbing effect
        const lfo = this.ctx.createOscillator();
        lfo.frequency.value = 0.2;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 50;
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        lfo.start();
    },

    playScreech: function() {
        // Jumpscare sound
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.5);
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.05);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.0);

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.0);
    }
};

// --- GAME OBJECTS ---
const keys = {};
const mouse = { x: 0, y: 0 };

const player = {
    x: 0, y: 0,
    radius: 10,
    angle: 0,
    sanity: 100,
    orbs: 0
};

const map = []; // 0 = floor, 1 = wall
const entities = []; // Enemies
const items = []; // Orbs
let exit = null;

// --- INITIALIZATION ---
function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    scareCanvas = document.getElementById('scareCanvas');
    scareCtx = scareCanvas.getContext('2d');

    resize();
    window.addEventListener('resize', resize);
    
    // Controls
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    window.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });

    document.getElementById('start-btn').addEventListener('click', startGame);
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    scareCanvas.width = 400;
    scareCanvas.height = 400;
}

function generateMap() {
    // Reset
    entities.length = 0;
    items.length = 0;
    
    // Simple Cellular Automata-ish / Room generation
    for(let y=0; y<MAP_HEIGHT; y++) {
        map[y] = [];
        for(let x=0; x<MAP_WIDTH; x++) {
            // Borders are walls, random noise inside
            if (x===0 || x===MAP_WIDTH-1 || y===0 || y===MAP_HEIGHT-1) map[y][x] = 1;
            else map[y][x] = Math.random() < 0.2 ? 1 : 0;
        }
    }
    
    // Find spawn
    let spawnFound = false;
    while(!spawnFound) {
        let rx = Math.floor(Math.random() * (MAP_WIDTH-2)) + 1;
        let ry = Math.floor(Math.random() * (MAP_HEIGHT-2)) + 1;
        if(map[ry][rx] === 0) {
            player.x = rx * TILE_SIZE + TILE_SIZE/2;
            player.y = ry * TILE_SIZE + TILE_SIZE/2;
            spawnFound = true;
        }
    }

    // Place Orbs
    for(let i=0; i<3; i++) {
        let placed = false;
        while(!placed) {
            let rx = Math.floor(Math.random() * (MAP_WIDTH-2)) + 1;
            let ry = Math.floor(Math.random() * (MAP_HEIGHT-2)) + 1;
            // Far enough from player
            let dx = rx*TILE_SIZE - player.x;
            let dy = ry*TILE_SIZE - player.y;
            if(map[ry][rx] === 0 && Math.sqrt(dx*dx+dy*dy) > 300) {
                items.push({x: rx*TILE_SIZE+TILE_SIZE/2, y: ry*TILE_SIZE+TILE_SIZE/2, type: 'orb', collected: false});
                placed = true;
            }
        }
    }

    // Place Exit
    let exitPlaced = false;
    while(!exitPlaced) {
        let rx = Math.floor(Math.random() * (MAP_WIDTH-2)) + 1;
        let ry = Math.floor(Math.random() * (MAP_HEIGHT-2)) + 1;
        let dx = rx*TILE_SIZE - player.x;
        let dy = ry*TILE_SIZE - player.y;
        if(map[ry][rx] === 0 && Math.sqrt(dx*dx+dy*dy) > 500) {
            exit = {x: rx*TILE_SIZE, y: ry*TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE};
            exitPlaced = true;
        }
    }

    // Add Enemies
    for(let i=0; i<3; i++) {
        let placed = false;
        while(!placed) {
            let rx = Math.floor(Math.random() * (MAP_WIDTH-2)) + 1;
            let ry = Math.floor(Math.random() * (MAP_HEIGHT-2)) + 1;
            let dx = rx*TILE_SIZE - player.x;
            let dy = ry*TILE_SIZE - player.y;
            if(map[ry][rx] === 0 && Math.sqrt(dx*dx+dy*dy) > 400) {
                entities.push({
                    x: rx*TILE_SIZE+TILE_SIZE/2, 
                    y: ry*TILE_SIZE+TILE_SIZE/2, 
                    state: 'idle', 
                    timer: 0,
                    type: 'glitch'
                });
                placed = true;
            }
        }
    }
}

function startGame() {
    AudioEngine.init();
    AudioEngine.playAmbient();
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    generateMap();
    player.sanity = 100;
    player.orbs = 0;
    gameState = 'PLAYING';
    lastTime = performance.now();
    requestAnimationFrame(loop);
}

// --- GAME LOOP ---
function loop(timestamp) {
    if(gameState !== 'PLAYING') return;

    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(dt);
    render();

    requestAnimationFrame(loop);
}

// --- LOGIC ---
function update(dt) {
    // 1. Player Movement
    let dx = 0;
    let dy = 0;
    if(keys['w'] || keys['arrowup']) dy = -1;
    if(keys['s'] || keys['arrowdown']) dy = 1;
    if(keys['a'] || keys['arrowleft']) dx = -1;
    if(keys['d'] || keys['arrowright']) dx = 1;

    // Normalize vector
    if(dx !== 0 || dy !== 0) {
        const len = Math.sqrt(dx*dx + dy*dy);
        dx /= len;
        dy /= len;
        
        // Try move X
        if(!checkCollision(player.x + dx * PLAYER_SPEED, player.y)) {
            player.x += dx * PLAYER_SPEED;
        }
        // Try move Y
        if(!checkCollision(player.x, player.y + dy * PLAYER_SPEED)) {
            player.y += dy * PLAYER_SPEED;
        }

        // Footstep sound
        if(Math.random() < 0.05) AudioEngine.playStep();
    }

    // 2. Player Angle (Look at Mouse - considering camera offset)
    // Camera centers on player
    const camX = player.x - width/2;
    const camY = player.y - height/2;
    const relMouseX = mouse.x + camX;
    const relMouseY = mouse.y + camY;
    
    player.angle = Math.atan2(relMouseY - player.y, relMouseX - player.x);

    // 3. Entity AI
    entities.forEach(ent => {
        // Distance to player
        const dist = Math.hypot(player.x - ent.x, player.y - ent.y);
        
        // Glitchy movement
        if(Math.random() < 0.1) {
            ent.x += (Math.random() - 0.5) * 10;
            ent.y += (Math.random() - 0.5) * 10;
        }

        // Stalk behavior
        if(dist < 300) {
            // Move towards player
            const angle = Math.atan2(player.y - ent.y, player.x - ent.x);
            // Speed increases if player sanity is low
            const speedMod = (100 - player.sanity) / 50 + 1;
            
            let ex = Math.cos(angle) * ENEMY_SPEED * speedMod;
            let ey = Math.sin(angle) * ENEMY_SPEED * speedMod;

            if(!checkCollision(ent.x + ex, ent.y)) ent.x += ex;
            if(!checkCollision(ent.x, ent.y + ey)) ent.y += ey;

            // Sanity drain
            player.sanity -= 0.05;
        } else {
            // Idle wander
            if(Math.random() < 0.02) {
                ent.dir = Math.random() * Math.PI * 2;
            }
            if(ent.dir) {
                let ex = Math.cos(ent.dir) * (ENEMY_SPEED * 0.5);
                let ey = Math.sin(ent.dir) * (ENEMY_SPEED * 0.5);
                if(!checkCollision(ent.x + ex, ent.y)) ent.x += ex;
                if(!checkCollision(ent.x, ent.y + ey)) ent.y += ey;
            }
        }

        // KILL
        if(dist < 20) {
            triggerJumpscare();
        }
    });

    // 4. Items & Exit
    items.forEach(item => {
        if(!item.collected && Math.hypot(player.x - item.x, player.y - item.y) < 20) {
            item.collected = true;
            player.orbs++;
            player.sanity = Math.min(100, player.sanity + 20);
            AudioEngine.playTone(400, 'sine', 0.2);
            AudioEngine.playTone(600, 'sine', 0.4);
        }
    });

    if(player.orbs >= 3) {
        // Check exit collision
        if(player.x > exit.x && player.x < exit.x + exit.w &&
           player.y > exit.y && player.y < exit.y + exit.h) {
             winGame();
           }
    }

    // 5. Sanity & UI
    player.sanity = Math.max(0, player.sanity - 0.01); // Passive drain
    document.getElementById('sanity-val').innerText = Math.floor(player.sanity);
    document.getElementById('orb-val').innerText = player.orbs;
    
    // Dynamic effects based on sanity
    const container = document.getElementById('game-container');
    if(player.sanity < 30 && Math.random() < 0.05) {
        container.style.filter = `hue-rotate(${Math.random()*360}deg)`;
        AudioEngine.playTone(100, 'sawtooth', 0.05, 0.02);
    } else {
        container.style.filter = 'none';
    }
}

function checkCollision(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    if(ty < 0 || ty >= MAP_HEIGHT || tx < 0 || tx >= MAP_WIDTH) return true;
    return map[ty][tx] === 1;
}

// --- RENDERING ---
function render() {
    // Camera calculation
    const camX = Math.floor(player.x - width/2);
    const camY = Math.floor(player.y - height/2);

    // 1. Clear Screen
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    ctx.translate(-camX, -camY);

    // 2. Draw Floor (Faint grid)
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let y=0; y<MAP_HEIGHT; y++) {
        for(let x=0; x<MAP_WIDTH; x++) {
            if(map[y][x] === 0) {
                // Determine screen pos to cull
                if (x*TILE_SIZE > camX + width || x*TILE_SIZE + TILE_SIZE < camX ||
                    y*TILE_SIZE > camY + height || y*TILE_SIZE + TILE_SIZE < camY) continue;
                
                ctx.rect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }
    ctx.stroke();

    // 3. Draw Walls
    ctx.fillStyle = '#222';
    for(let y=0; y<MAP_HEIGHT; y++) {
        for(let x=0; x<MAP_WIDTH; x++) {
            if(map[y][x] === 1) {
                if (x*TILE_SIZE > camX + width || x*TILE_SIZE + TILE_SIZE < camX) continue;
                ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                // Detail
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(x*TILE_SIZE + 5, y*TILE_SIZE + 5, TILE_SIZE-10, TILE_SIZE-10);
                ctx.fillStyle = '#222';
            }
        }
    }

    // 4. Draw Items
    items.forEach(item => {
        if(!item.collected) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'cyan';
            ctx.fillStyle = '#aff';
            ctx.beginPath();
            ctx.arc(item.x, item.y, 6, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    // 5. Draw Exit
    if(exit) {
        ctx.fillStyle = player.orbs >= 3 ? '#0f0' : '#300';
        ctx.fillRect(exit.x, exit.y, exit.w, exit.h);
        ctx.font = '10px monospace';
        ctx.fillStyle = 'white';
        ctx.fillText("EXIT", exit.x+5, exit.y+20);
    }

    // 6. Draw Enemies (If revealed) - Actually let's draw them, lighting will hide them
    entities.forEach(ent => {
        ctx.save();
        ctx.translate(ent.x, ent.y);
        
        // Glitch effect drawing
        ctx.strokeStyle = '#800';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<5; i++) {
            ctx.moveTo((Math.random()-0.5)*20, (Math.random()-0.5)*20);
            ctx.lineTo((Math.random()-0.5)*20, (Math.random()-0.5)*20);
        }
        ctx.stroke();
        
        // Red Eyes
        ctx.fillStyle = 'red';
        ctx.fillRect(-5, -5, 2, 2);
        ctx.fillRect(3, -5, 2, 2);
        
        ctx.restore();
    });

    // 7. Draw Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.fillStyle = '#ccc';
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI*2);
    ctx.fill();
    // Flashlight casing
    ctx.fillStyle = '#555';
    ctx.fillRect(0, -3, 12, 6);
    ctx.restore();

    ctx.restore(); // End World Space

    // --- LIGHTING SYSTEM (The Horror Element) ---
    // We cover everything in black, then "cut out" the flashlight cone
    
    // 1. Create Darkness Layer
    ctx.fillStyle = `rgba(0, 0, 0, ${player.sanity > 50 ? 0.95 : 0.98})`; // Darker when insane
    ctx.fillRect(0, 0, width, height);

    // 2. Set blend mode to cut out light
    ctx.globalCompositeOperation = 'destination-out';

    // 3. Draw Flashlight Cone
    ctx.save();
    ctx.translate(width/2, height/2); // Player is always center of screen
    ctx.rotate(player.angle);

    // Gradient for soft light edge
    const rad = ctx.createRadialGradient(0, 0, 10, 0, 0, FLASHLIGHT_RADIUS);
    rad.addColorStop(0, 'rgba(255, 255, 255, 1)');
    rad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = rad;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, FLASHLIGHT_RADIUS, -FLASHLIGHT_ANGLE, FLASHLIGHT_ANGLE);
    ctx.lineTo(0,0);
    ctx.fill();
    
    ctx.restore();

    // 4. Draw Player Halo (small light around player so you see yourself)
    ctx.beginPath();
    ctx.arc(width/2, height/2, 20, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fill();

    // Reset composite
    ctx.globalCompositeOperation = 'source-over';
}

// --- JUMPSCARE & DEATH ---
function triggerJumpscare() {
    gameState = 'DEAD';
    AudioEngine.playScreech();
    
    const overlay = document.getElementById('jumpscare-overlay');
    overlay.style.display = 'flex';
    document.getElementById('hud').style.display = 'none';

    // Procedural Face Gen
    let frame = 0;
    const interval = setInterval(() => {
        scareCtx.fillStyle = frame % 2 === 0 ? 'black' : 'white';
        scareCtx.fillRect(0,0,400,400);
        
        scareCtx.fillStyle = frame % 2 === 0 ? 'white' : 'black';
        // Eyes
        scareCtx.beginPath();
        scareCtx.arc(120, 150, 40 + Math.random()*10, 0, Math.PI*2);
        scareCtx.arc(280, 150, 40 + Math.random()*10, 0, Math.PI*2);
        scareCtx.fill();
        
        // Screaming Mouth
        scareCtx.beginPath();
        scareCtx.ellipse(200, 300, 60, 100 + Math.random()*20, 0, 0, Math.PI*2);
        scareCtx.fill();

        frame++;
        if(frame > 10) {
            clearInterval(interval);
            overlay.style.display = 'none';
            document.getElementById('death-screen').style.display = 'flex';
        }
    }, 50);
}

function winGame() {
    gameState = 'WIN';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('win-screen').style.display = 'flex';
}

// Start Init
window.onload = init;

</script>
</body>
</html>
